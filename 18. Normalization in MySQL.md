

# ðŸ“˜ **Normalization in MySQL**

## 1. **Introduction**

* **Normalization** is the process of organizing data in a database to reduce **redundancy** (duplicate data) and improve **data integrity**.
* Goal: Split large tables into smaller related tables and define **relationships** between them.
* Normalization ensures:

  * No duplicate data
  * Consistent and accurate data
  * Efficient queries and storage

---

## 2. **Why Normalization is Needed?**

* Avoid storing the same data multiple times.
* Prevent **anomalies**:

  1. **Insertion Anomaly** â€“ Canâ€™t insert data due to missing other details.
  2. **Update Anomaly** â€“ Updating one row requires updating many others.
  3. **Deletion Anomaly** â€“ Deleting a record accidentally removes important data.

---

## 3. **Types of Anomalies (Example)**

Suppose we have a single table:

| StudentID | StudentName | Course | Instructor |
| --------- | ----------- | ------ | ---------- |
| 101       | Ravi        | DBMS   | Dr. Sharma |
| 102       | Anil        | Java   | Dr. Reddy  |
| 101       | Ravi        | Java   | Dr. Reddy  |

* **Update Anomaly**: If instructor name for Java changes, we must update in multiple rows.
* **Insertion Anomaly**: If a new course is added without students, canâ€™t insert.
* **Deletion Anomaly**: If Ravi leaves, we also lose DBMS course info.

---

## 4. **Normal Forms in MySQL**

### **1NF (First Normal Form)**

* Each column must have **atomic values** (no multiple values in a single cell).
* No **repeating groups/arrays**.

âœ… **Solution**: Split multivalued data into separate rows.

**Before (Unnormalized Table):**

| StudentID | Name | Courses    |
| --------- | ---- | ---------- |
| 101       | Ravi | DBMS, Java |

**After (1NF):**

| StudentID | Name | Course |
| --------- | ---- | ------ |
| 101       | Ravi | DBMS   |
| 101       | Ravi | Java   |

---

### **2NF (Second Normal Form)**

* Must be in **1NF**.
* No **partial dependency** (non-key attribute depends on part of a composite key).

âœ… **Solution**: Split table into separate tables.

**Before (1NF):**

| StudentID | CourseID | StudentName | CourseName |
| --------- | -------- | ----------- | ---------- |
| 101       | C1       | Ravi        | DBMS       |
| 102       | C2       | Anil        | Java       |

Here, `StudentName` depends only on `StudentID`, not on the full composite key `(StudentID, CourseID)` â†’ partial dependency.

**After (2NF):**

**Student Table**

| StudentID | StudentName |
| --------- | ----------- |
| 101       | Ravi        |
| 102       | Anil        |

**Course Table**

| CourseID | CourseName |
| -------- | ---------- |
| C1       | DBMS       |
| C2       | Java       |

**Enrollment Table**

| StudentID | CourseID |
| --------- | -------- |
| 101       | C1       |
| 101       | C2       |
| 102       | C2       |

---

### **3NF (Third Normal Form)**

* Must be in **2NF**.
* No **transitive dependency** (non-key attribute depends on another non-key attribute).

âœ… **Solution**: Remove transitive dependencies.

**Before (2NF):**

| StudentID | StudentName | DeptID | DeptName |
| --------- | ----------- | ------ | -------- |
| 101       | Ravi        | D1     | Computer |
| 102       | Anil        | D2     | IT       |

Here, `DeptName` depends on `DeptID`, not directly on `StudentID`.

**After (3NF):**

**Department Table**

| DeptID | DeptName |
| ------ | -------- |
| D1     | Computer |
| D2     | IT       |

**Student Table**

| StudentID | StudentName | DeptID |
| --------- | ----------- | ------ |
| 101       | Ravi        | D1     |
| 102       | Anil        | D2     |

---

### **BCNF (Boyce-Codd Normal Form)**

* A stricter version of 3NF.
* Every determinant must be a **candidate key**.
* Used when anomalies still exist in **3NF**.

**Example**:

| Teacher | Subject | Dept |
| ------- | ------- | ---- |
| Reddy   | DBMS    | CSE  |
| Sharma  | Java    | CSE  |

Here, `(Teacher â†’ Subject)` and `(Subject â†’ Teacher)` both work, but not all determinants are candidate keys.
âœ… Split into separate tables.

---

### **4NF (Fourth Normal Form)**

* Must be in **BCNF**.
* No **multi-valued dependency**.

---

### **5NF (Fifth Normal Form)**

* Must be in **4NF**.
* No **join dependency**; table should not be split further without losing data.

---

## 5. **Summary Table of Normal Forms**

| Normal Form | Rule                                       | Removes                   |
| ----------- | ------------------------------------------ | ------------------------- |
| **1NF**     | Atomic values, no repeating groups         | Repetition in columns     |
| **2NF**     | 1NF + No partial dependency                | Partial dependency        |
| **3NF**     | 2NF + No transitive dependency             | Transitive dependency     |
| **BCNF**    | 3NF + Every determinant is a candidate key | Remaining anomalies       |
| **4NF**     | BCNF + No multi-valued dependency          | Multi-valued dependencies |
| **5NF**     | 4NF + No join dependency                   | Join anomalies            |

---

## 6. **Advantages of Normalization**

* Removes duplicate data.
* Saves storage space.
* Prevents anomalies.
* Makes queries faster and more reliable.
* Increases flexibility in data manipulation.

---

## 7. **Disadvantages of Over-Normalization**

* Too many small tables â†’ complex joins.
* Performance may reduce for read-heavy applications.
* Sometimes **denormalization** is used in real-world systems for speed.

---

âœ… **Real-World Use Case in MySQL**

* **E-commerce Database**: Customers, Orders, Products.

  * Instead of storing all customer and product details in one "Orders" table,
  * We normalize into `Customer`, `Product`, `Order`, `OrderDetails`.


