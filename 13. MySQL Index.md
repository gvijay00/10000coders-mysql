---
title: MySQL Index

---


#  **MySQL Index**


## 🔹 1. Definition

An **Index** in MySQL is a **data structure** that improves the speed of data retrieval operations on a table.
It works like the **index of a book** → instead of scanning every page, MySQL can quickly locate the required rows.

* **Index = Reference to data location.**
* Makes `SELECT` queries faster, especially with `WHERE`, `JOIN`, `ORDER BY`, and `GROUP BY`.
* Maintained automatically during `INSERT`, `UPDATE`, and `DELETE`.

👉 Without an index → MySQL scans the **entire table** (Full Table Scan).
👉 With an index → MySQL uses **fast lookup** (usually B-Tree or Hash).

---

## 🔹 2. Why Use Index?

✅ Faster **read/search** performance
✅ Helps with **query filtering** (`WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`)
✅ Enforces **uniqueness** (`PRIMARY KEY`, `UNIQUE`)
✅ Efficient **full-text search**

❌ But… **slows down writes** (`INSERT`, `UPDATE`, `DELETE`) because indexes must also be updated.
❌ Requires **extra storage space**.

---

## 🔹 3. Index Creation Syntax

### 🟢 At Table Creation

```sql
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
    INDEX (column1)
);
```

### 🟢 On Existing Table

```sql
CREATE INDEX index_name 
ON table_name (column_name);
```

### 🟢 Primary Key Index

```sql
CREATE TABLE Students (
    id INT,
    name VARCHAR(50),
    PRIMARY KEY (id)
);
```

### 🟢 Unique Index

```sql
CREATE UNIQUE INDEX idx_email 
ON Students(email);
```

### 🟢 Regular (Non-Unique) Index

```sql
CREATE INDEX idx_name 
ON Students(name);
```

### 🟢 Composite Index (Multi-Column)

```sql
CREATE INDEX idx_name_age 
ON Students(name, age);
```

### 🟢 Full-Text Index

```sql
CREATE FULLTEXT INDEX idx_desc 
ON Products(description);
```

### 🟢 Spatial Index

```sql
CREATE SPATIAL INDEX idx_location 
ON Places(location);
```

---

## 🔹 4. Managing Indexes

### View Indexes

```sql
SHOW INDEX FROM table_name;
```

### Drop Index

```sql
DROP INDEX index_name 
ON table_name;
```

---

## 🔹 5. Types of Index in MySQL

| **Index Type**        | **Purpose**               | **Key Feature**                                                |
| --------------------- | ------------------------- | -------------------------------------------------------------- |
| **Primary Key**       | Unique row identification | Enforces uniqueness + NOT NULL, auto-created with PRIMARY KEY. |
| **Unique Index**      | Enforces uniqueness       | Prevents duplicate values, allows NULL.                        |
| **Regular (Simple)**  | Speeds up lookups         | Allows duplicates + NULLs.                                     |
| **Composite Index**   | Multi-column optimization | Column order matters; useful for combined queries.             |
| **Fulltext Index**    | Full-text searching       | Works on `CHAR`, `VARCHAR`, `TEXT`.                            |
| **Spatial Index**     | For geospatial data       | Works with `POINT`, `GEOMETRY`.                                |
| **Foreign Key Index** | Referential integrity     | Auto-created when defining foreign keys.                       |
| **Hash Index**        | Fast equality lookups     | Available in MEMORY engine, not range queries.                 |

---

## 🔹 6. How Index Works (Internals)

* Most indexes use **B-Tree structure** → O(log n) lookup.
* **Hash index** is faster for `=` but doesn’t support range queries (`>`, `<`).
* Indexes are stored **alongside table data** and auto-updated.

---

## 🔹 7. Advantages

✅ Faster SELECT queries.
✅ Efficient filtering, sorting, joining.
✅ Enforces uniqueness (with `PRIMARY KEY`, `UNIQUE`).
✅ Optimized full-text search.

---

## 🔹 8. Disadvantages

❌ Extra disk space required.
❌ Slower writes (INSERT, UPDATE, DELETE).
❌ Over-indexing can harm performance.

---

## 🔹 9. Best Practices

✔ Index columns used in `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.
✔ Use **composite indexes** for multi-column filtering.
✔ Don’t index every column (wastes storage + slows writes).
✔ Use **EXPLAIN** to check if an index is being used:

```sql
EXPLAIN SELECT * FROM Students WHERE name='Rajesh';
```

---

## 🔹 10. Real-World Example

```sql
CREATE TABLE Employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    department VARCHAR(50),
    salary DECIMAL(10,2),
    INDEX idx_dept_salary (department, salary)
);

-- Optimized query using index
SELECT * FROM Employees
WHERE department='HR' AND salary > 50000;
```

👉 `PRIMARY KEY` → `emp_id`
👉 `UNIQUE INDEX` → `email`
👉 `COMPOSITE INDEX` → `(department, salary)` speeds up HR queries

---

## 🔹 11. Summary Table

| **Feature**          | **With Index**               | **Without Index**        |
| -------------------- | ---------------------------- | ------------------------ |
| SELECT query speed   | 🚀 Fast                      | 🐌 Slow (full scan)      |
| INSERT/UPDATE/DELETE | Slower (index update needed) | Faster                   |
| Storage requirement  | More (extra index data)      | Less                     |
| Best use case        | Read-heavy applications      | Write-heavy applications |

---

✅ **In Summary:**
Indexes are **powerful performance boosters** in MySQL. They make **reads faster** but can **slow down writes**. Choosing the **right type** and **placing indexes on the right columns** is essential for efficient database design.

---
