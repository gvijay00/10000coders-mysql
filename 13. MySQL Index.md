---
title: MySQL Index

---


#  **MySQL Index**


## ğŸ”¹ 1. Definition

An **Index** in MySQL is a **data structure** that improves the speed of data retrieval operations on a table.
It works like the **index of a book** â†’ instead of scanning every page, MySQL can quickly locate the required rows.

* **Index = Reference to data location.**
* Makes `SELECT` queries faster, especially with `WHERE`, `JOIN`, `ORDER BY`, and `GROUP BY`.
* Maintained automatically during `INSERT`, `UPDATE`, and `DELETE`.

ğŸ‘‰ Without an index â†’ MySQL scans the **entire table** (Full Table Scan).
ğŸ‘‰ With an index â†’ MySQL uses **fast lookup** (usually B-Tree or Hash).

---

## ğŸ”¹ 2. Why Use Index?

âœ… Faster **read/search** performance
âœ… Helps with **query filtering** (`WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`)
âœ… Enforces **uniqueness** (`PRIMARY KEY`, `UNIQUE`)
âœ… Efficient **full-text search**

âŒ Butâ€¦ **slows down writes** (`INSERT`, `UPDATE`, `DELETE`) because indexes must also be updated.
âŒ Requires **extra storage space**.

---

## ğŸ”¹ 3. Index Creation Syntax

### ğŸŸ¢ At Table Creation

```sql
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
    INDEX (column1)
);
```

### ğŸŸ¢ On Existing Table

```sql
CREATE INDEX index_name 
ON table_name (column_name);
```

### ğŸŸ¢ Primary Key Index

```sql
CREATE TABLE Students (
    id INT,
    name VARCHAR(50),
    PRIMARY KEY (id)
);
```

### ğŸŸ¢ Unique Index

```sql
CREATE UNIQUE INDEX idx_email 
ON Students(email);
```

### ğŸŸ¢ Regular (Non-Unique) Index

```sql
CREATE INDEX idx_name 
ON Students(name);
```

### ğŸŸ¢ Composite Index (Multi-Column)

```sql
CREATE INDEX idx_name_age 
ON Students(name, age);
```

### ğŸŸ¢ Full-Text Index

```sql
CREATE FULLTEXT INDEX idx_desc 
ON Products(description);
```

### ğŸŸ¢ Spatial Index

```sql
CREATE SPATIAL INDEX idx_location 
ON Places(location);
```

---

## ğŸ”¹ 4. Managing Indexes

### View Indexes

```sql
SHOW INDEX FROM table_name;
```

### Drop Index

```sql
DROP INDEX index_name 
ON table_name;
```

---

## ğŸ”¹ 5. Types of Index in MySQL

| **Index Type**        | **Purpose**               | **Key Feature**                                                |
| --------------------- | ------------------------- | -------------------------------------------------------------- |
| **Primary Key**       | Unique row identification | Enforces uniqueness + NOT NULL, auto-created with PRIMARY KEY. |
| **Unique Index**      | Enforces uniqueness       | Prevents duplicate values, allows NULL.                        |
| **Regular (Simple)**  | Speeds up lookups         | Allows duplicates + NULLs.                                     |
| **Composite Index**   | Multi-column optimization | Column order matters; useful for combined queries.             |
| **Fulltext Index**    | Full-text searching       | Works on `CHAR`, `VARCHAR`, `TEXT`.                            |
| **Spatial Index**     | For geospatial data       | Works with `POINT`, `GEOMETRY`.                                |
| **Foreign Key Index** | Referential integrity     | Auto-created when defining foreign keys.                       |
| **Hash Index**        | Fast equality lookups     | Available in MEMORY engine, not range queries.                 |

---

## ğŸ”¹ 6. How Index Works (Internals)

* Most indexes use **B-Tree structure** â†’ O(log n) lookup.
* **Hash index** is faster for `=` but doesnâ€™t support range queries (`>`, `<`).
* Indexes are stored **alongside table data** and auto-updated.

---

## ğŸ”¹ 7. Advantages

âœ… Faster SELECT queries.
âœ… Efficient filtering, sorting, joining.
âœ… Enforces uniqueness (with `PRIMARY KEY`, `UNIQUE`).
âœ… Optimized full-text search.

---

## ğŸ”¹ 8. Disadvantages

âŒ Extra disk space required.
âŒ Slower writes (INSERT, UPDATE, DELETE).
âŒ Over-indexing can harm performance.

---

## ğŸ”¹ 9. Best Practices

âœ” Index columns used in `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.
âœ” Use **composite indexes** for multi-column filtering.
âœ” Donâ€™t index every column (wastes storage + slows writes).
âœ” Use **EXPLAIN** to check if an index is being used:

```sql
EXPLAIN SELECT * FROM Students WHERE name='Rajesh';
```

---

## ğŸ”¹ 10. Real-World Example

```sql
CREATE TABLE Employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    department VARCHAR(50),
    salary DECIMAL(10,2),
    INDEX idx_dept_salary (department, salary)
);

-- Optimized query using index
SELECT * FROM Employees
WHERE department='HR' AND salary > 50000;
```

ğŸ‘‰ `PRIMARY KEY` â†’ `emp_id`
ğŸ‘‰ `UNIQUE INDEX` â†’ `email`
ğŸ‘‰ `COMPOSITE INDEX` â†’ `(department, salary)` speeds up HR queries

---

## ğŸ”¹ 11. Summary Table

| **Feature**          | **With Index**               | **Without Index**        |
| -------------------- | ---------------------------- | ------------------------ |
| SELECT query speed   | ğŸš€ Fast                      | ğŸŒ Slow (full scan)      |
| INSERT/UPDATE/DELETE | Slower (index update needed) | Faster                   |
| Storage requirement  | More (extra index data)      | Less                     |
| Best use case        | Read-heavy applications      | Write-heavy applications |

---

âœ… **In Summary:**
Indexes are **powerful performance boosters** in MySQL. They make **reads faster** but can **slow down writes**. Choosing the **right type** and **placing indexes on the right columns** is essential for efficient database design.

---
